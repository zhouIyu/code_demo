<!-- TOC -->

- [JS](#js)
  - [请解释 JavaScript 中的事件循环（Event Loop）机制，并说明宏任务（macrotask）与微任务（microtask）的执行顺序差异。​](#%E8%AF%B7%E8%A7%A3%E9%87%8A-javascript-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop%E6%9C%BA%E5%88%B6%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1macrotask%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1microtask%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%B7%AE%E5%BC%82%E2%80%8B)
  - [闭包](#%E9%97%AD%E5%8C%85)
  - [前端报错监听](#%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99%E7%9B%91%E5%90%AC)
  - [如何计算白屏时间](#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4)
  - [首屏优化的方法](#%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95)
  - [如何中断一个http请求](#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82)
  - [websocket 心跳检测机制](#websocket-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6)
- [CSS](#css)
- [Vue](#vue)
  - [computed 和 watch 的区别](#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [v-model 双向绑定的实现](#v-model-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0)
  - [Vue2 和 Vue3 实现响应式的区别](#vue2-%E5%92%8C-vue3-%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [Vue 2.x Object.defineProperty的局限性](#vue-2x-objectdefineproperty%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7)
  - [Virtual DOM 工作原理](#virtual-dom-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [对于Vue2, Vue3针对于虚拟DOM有哪些升级](#%E5%AF%B9%E4%BA%8Evue2-vue3%E9%92%88%E5%AF%B9%E4%BA%8E%E8%99%9A%E6%8B%9Fdom%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%87%E7%BA%A7)
  - [Key的作用](#key%E7%9A%84%E4%BD%9C%E7%94%A8)
  - [封装组件的原则](#%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%88%99)
  - [v-if 和 v-show的区别](#v-if-%E5%92%8C-v-show%E7%9A%84%E5%8C%BA%E5%88%AB)
- [网络](#%E7%BD%91%E7%BB%9C)
  - [浏览器URL的加载和渲染](#%E6%B5%8F%E8%A7%88%E5%99%A8url%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%B8%B2%E6%9F%93)
  - [请解释浏览器缓存机制，并说明强缓存与协商缓存的区别及实现方式。​](#%E8%AF%B7%E8%A7%A3%E9%87%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E2%80%8B)
- [工程化](#%E5%B7%A5%E7%A8%8B%E5%8C%96)
  - [请解释前端工程化中的 Tree Shaking 原理。​](#%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%AD%E7%9A%84-tree-shaking-%E5%8E%9F%E7%90%86%E2%80%8B)
  - [什么是浏览器的ES Module](#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84es-module)
  - [Webpack 中loader 和 Plugin的区别](#webpack-%E4%B8%ADloader-%E5%92%8C-plugin%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [Webpack的hash值有几种](#webpack%E7%9A%84hash%E5%80%BC%E6%9C%89%E5%87%A0%E7%A7%8D)
  - [如何优化发布打包时长](#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%8F%91%E5%B8%83%E6%89%93%E5%8C%85%E6%97%B6%E9%95%BF)
  - [Vite 为什么本地启动比Webpack 快？](#vite-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E6%AF%94webpack-%E5%BF%AB)
- [TS](#ts)
  - [void/never 的区别](#voidnever-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [interface与type的区别](#interface%E4%B8%8Etype%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [为什么需要泛型](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B)
  - [什么是泛型约束](#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F)
  - [解释条件类型的语法 T extends U ? X : Y，并举例说明其用途](#%E8%A7%A3%E9%87%8A%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95-t-extends-u--x--y%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%85%B6%E7%94%A8%E9%80%94)
  - [​​实现 Exclude<T, U>​​（排除 T中可赋值给 U的类型）](#%E2%80%8B%E2%80%8B%E5%AE%9E%E7%8E%B0-excludet-u%E2%80%8B%E2%80%8B%E6%8E%92%E9%99%A4-t%E4%B8%AD%E5%8F%AF%E8%B5%8B%E5%80%BC%E7%BB%99-u%E7%9A%84%E7%B1%BB%E5%9E%8B)
  - [如何用条件类型判断一个类型是否是数组？（如 T extends any[] ? true : false）](#%E5%A6%82%E4%BD%95%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%E5%A6%82-t-extends-any--true--false)
  - [什么是映射类型？如何用映射类型将对象的所有属性变为可选或只读？（如 Partial、Readonly）](#%E4%BB%80%E4%B9%88%E6%98%AF%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E7%94%A8%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E5%8F%98%E4%B8%BA%E5%8F%AF%E9%80%89%E6%88%96%E5%8F%AA%E8%AF%BB%E5%A6%82-partialreadonly)
  - [实现一个工具类型 CamelToKebabCase，将对象属性名的驼峰命名转为短横线命名（如 { fooBar: 1 }→ { 'foo-bar': 1 }）。](#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B-cameltokebabcase%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%BD%AC%E4%B8%BA%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D%E5%A6%82--foobar-1-%E2%86%92--foo-bar-1-)
  - [infer关键字的作用是什么？如何在条件类型中使用 infer？](#infer%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-infer)
  - [用 infer实现 ReturnType工具类型（获取函数类型的返回值类型）。](#%E7%94%A8-infer%E5%AE%9E%E7%8E%B0-returntype%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B)
  - [如何为第三方库（如 lodash）添加类型声明？.d.ts文件的作用是什么？](#%E5%A6%82%E4%BD%95%E4%B8%BA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A6%82-lodash%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8Edts%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)
  - [Vue 3 中 defineComponent如何增强 TS 类型推导？举例说明。](#vue-3-%E4%B8%AD-definecomponent%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA-ts-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E)
  - [tsconfig.json中 strict模式的含义是什么？开启后会影响哪些检查项？](#tsconfigjson%E4%B8%AD-strict%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E5%BC%80%E5%90%AF%E5%90%8E%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%93%AA%E4%BA%9B%E6%A3%80%E6%9F%A5%E9%A1%B9)
  - [noImplicitAny和 strictNullChecks的作用是什么？为什么推荐开启？](#noimplicitany%E5%92%8C-strictnullchecks%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E5%BC%80%E5%90%AF)
  - [如何优化 TS 编译速度？](#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-ts-%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6)
  - [为什么避免滥用 any？如何逐步迁移项目中的 any类型？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8D%E6%BB%A5%E7%94%A8-any%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E8%BF%81%E7%A7%BB%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84-any%E7%B1%BB%E5%9E%8B)
  - [实现一个类型工具 PickByType<T, U>，从类型 T中筛选出属性值为 U类型的属性。示例：PickByType<{ name: string; age: number }, string>应返回 { name: string }。](#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7-pickbytypet-u%E4%BB%8E%E7%B1%BB%E5%9E%8B-t%E4%B8%AD%E7%AD%9B%E9%80%89%E5%87%BA%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BA-u%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8Bpickbytype-name-string-age-number--string%E5%BA%94%E8%BF%94%E5%9B%9E--name-string-)
  - [用泛型和类型约束实现一个 DeepReadonly类型，将对象的所有嵌套属性变为只读。示例：DeepReadonly<{ a: { b: number } }>应返回 { readonly a: { readonly b: number } }。](#%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-deepreadonly%E7%B1%BB%E5%9E%8B%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B5%8C%E5%A5%97%E5%B1%9E%E6%80%A7%E5%8F%98%E4%B8%BA%E5%8F%AA%E8%AF%BB%E7%A4%BA%E4%BE%8Bdeepreadonly-a--b-number--%E5%BA%94%E8%BF%94%E5%9B%9E--readonly-a--readonly-b-number--)
  - [修复以下代码的类型错误：](#%E4%BF%AE%E5%A4%8D%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF)
- [场景题](#%E5%9C%BA%E6%99%AF%E9%A2%98)
  - [单点登录](#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95)
- [编码](#%E7%BC%96%E7%A0%81)
  - [最长递增子序列](#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97)
  - [滑动窗口](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)
  - [防抖](#%E9%98%B2%E6%8A%96)
  - [节流](#%E8%8A%82%E6%B5%81)
  - [Promise.all](#promiseall)
  - [实现一个函数 deepEqual深度比较两个对象是否相等](#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-deepequal%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89)
  - [实现-个函数 deepClone 深拷贝](#%E5%AE%9E%E7%8E%B0-%E4%B8%AA%E5%87%BD%E6%95%B0-deepclone-%E6%B7%B1%E6%8B%B7%E8%B4%9D)
  - [DFS 实现 dom节点的查找](#dfs-%E5%AE%9E%E7%8E%B0-dom%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE)
  - [多维数组扁平化实现​](#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%AE%9E%E7%8E%B0%E2%80%8B)

<!-- /TOC -->
## JS 

### 请解释 JavaScript 中的事件循环（Event Loop）机制，并说明宏任务（macrotask）与微任务（microtask）的执行顺序差异。​

  由于JS 是单线程的，容易造成线程阻塞；通过事件循环机制，生成异步任务，解决这一问题；
    
  事件循环机制：
    1. 主线程执行调用栈中的同步任务，将遇到的微任务交给微任务队列；宏任务交给Web APIS 处理
    2. 执行完同步任务后，清空微任务队列
    3. 清空微任务队列后，取一个宏任务执行
    4. 重复上面过程

### 闭包

1. 定义：​​闭包是函数与其词法环境（Lexical Environment）的组合体​​，允许函数在定义后，仍然能访问其定义时所在的词法作用域中的变量（即使函数在其原始作用域之外执行）
2. 使用场景：
   1. 数据封装与私有变量 JavaScript 没有原生的“私有属性”语法（ES6 类的 #私有字段是语法糖），但闭包可以模拟私有变量，避免数据被外部直接修改。
   2. 函数记忆 缓存函数的计算结果，避免重复计算，闭包用于存储已计算的结果。
   3. 柯里化 柯里化是将多参数函数转换为单参数函数链的技术，闭包用于保存已传入的参数。
   4. 事件处理与异步回调 在事件监听或异步操作中，闭包可以保留当前上下文的变量，避免因作用域覆盖导致的问题。​
   5. 模块模式（隔离作用域）​通过闭包创建独立模块，暴露公共接口，隐藏内部实现细节，避免全局污染。

### 前端报错监听

1. Script 报错​​：通过 window.onerror或 addEventListener('error')捕获全局 JS 错误和资源加载错误。
2. Promise 报错​​：通过 addEventListener('unhandledrejection')捕获未处理的异步 Promise 错误。
3. ​​Vue 报错​​：Vue 2 用 Vue.config.errorHandler，Vue 3 用 app.config.errorHandler或 errorCaptured钩子捕获组件级错误

### 如何计算白屏时间

关键性能指标（KPI）​​

​- ​navigationStart​​：页面导航开始的绝对时间（浏览器开始加载页面的时刻）。
- ​​firstContentfulPaint（FCP）​​：浏览器首次绘制任何文本、图片、SVG 或非空白 Canvas 的时间（用户首次看到“内容”的时刻）。
​- ​firstPaint（FP）​​：浏览器首次绘制任何像素（包括空白）的时间（早于 FCP，可能只是背景色）。
​- ​largestContentfulPaint（LCP）​​：页面中最大内容元素（如图片、文本块）渲染完成的时间（更贴近用户感知的“主要内容加载完成”）。

计算白屏时间的核心是通过 firstContentfulPaint（FCP）与 navigationStart的时间差衡量用户感知的空白期。

```js
// 获取导航开始时间
const navigationEntry = performance.getEntriesByType('navigation')[0];
const navigationStart = navigationEntry.startTime;

// 监听 FCP（首次内容绘制）
const observer = new PerformanceObserver((list) => {
  const paintEntries = list.getEntriesByName('first-contentful-paint');
  if (paintEntries.length > 0) {
    const fcp = paintEntries[0].startTime;
    const whiteScreenTime = fcp - navigationStart;
    console.log(`白屏时间: ${whiteScreenTime}ms`);
    observer.disconnect(); // 停止监听
  }
});

// 观察 paint 类型的性能条目
observer.observe({ type: 'paint', buffered: true });

```


### 首屏优化的方法

1. 内联关键 CSS​​：将首屏必需的 CSS 直接内联到 HTML <style>标签中（避免外部 CSS 文件阻塞渲染）
2. ​​预加载关键资源​​：使用 <link rel="preload">告知浏览器优先加载首屏必需的 JS/CSS/图片（如首屏大图、核心 JS 库）
3. 延迟加载非关键资源​​：非首屏 JS 使用 async或 defer属性, 非首屏图片使用懒加载（loading="lazy"），仅在用户滚动到可视区域时加载。

### 如何中断一个http请求

```js
// xhr
xhr.abort()

// fetch
const controller = new AbortController()
const signal = controller.signal

fetch('xxx', {signal})

controller.abort()
```

### websocket 心跳检测机制



## CSS

## Vue

### computed 和 watch 的区别
### v-model 双向绑定的实现
  v-model 是Vue提供的语法糖，用于在表单元素或者自定义组件上实现双向绑定；它的本质是v-bind和v-on 的组合

  vue2 :value @input

  vue3 :modelValue @update:modelValue

### Vue2 和 Vue3 实现响应式的区别

  Vue2 使用Object.defineProperty对整个数据对象进行劫持，为每个属性都添加getter和setter方法；当读取属性时，触发getter方法；当修改属性时，触发setter方法；

  Vue3 使用Proxy对整个对象进行代理，它可以监听对象的各个操作，如属性的读取，设置，删除；

  Vue3 和 Vue2相比能够监听动态添加的属性，以及数组的变化等；

### Vue 2.x Object.defineProperty的局限性

  1. 无法监听动态添加的属性和删除，通过Vue.set和Vue.delete实现来确保响应式
  2. 无法监听数组索引的变化和数组长度的变化，通过复写push、pop等方法实现响应式
  
### Virtual DOM 工作原理

  用轻量的 JavaScript 对象替代真实 DOM，先在内存中处理数据变化，再批量更新真实 DOM，从而减少 “昂贵” 的真实 DOM 操作。

  当数据发生变化时，会生成新的虚拟 DOM 树，然后通过 Diff 算法将新虚拟 DOM 树与旧的虚拟 DOM 树进行对比，找出差异部分，最后只更新需要更新的真实 DOM 节点，提高更新效率。

### 对于Vue2, Vue3针对于虚拟DOM有哪些升级

1. 静态标记(Patch Flag)

### Key的作用

  在Vue中，key用于给节点做唯一标识；帮组Vue更加搞笑的更新虚拟DOM;
### 封装组件的原则

  1. 单一职责原则，每个组件应该只负责一个特定的功能；或者当组件变得复杂时考虑拆分为更小的子组件；
  2. 高内聚低耦合，组件之间应该是 紧密相关的
  3. 可复用性，组件应该是独立于特定业务场景的
  4. 可组合性，使用children或slot机制实现组件组合，避免过度嵌套，保持组件层次扁平

### v-if 和 v-show的区别

## 网络

  ### 浏览器URL的加载和渲染

  输入URL -> 判断是否有缓存 -> 解析DNS -> 建立TCP 连接 -> （建立TLS连接 https）->
  发送HTTP请求 -> 服务器处理请求 -> 处理HTTP响应 -> 渲染页面 -> 断开连接

  解析DNS 过程：判断本地是否有IP缓存 -> 本地DNS服务器一层一层往上查询

  渲染页面过程：构建DOM树 -> 构建CSSOM 树 -> 合并DOM树和CSSOM树生成渲染树 -> 布局 -> 重绘

  ### 请解释浏览器缓存机制，并说明强缓存与协商缓存的区别及实现方式。​

  浏览器缓存核心机制：
  1. 判断是否有缓存
  2. 无缓存时，向服务器请求
  3. 有缓存时，判断是否强缓存有效
  4. 有效，直接使用强缓存
  5. 无效，校验协商缓存
  6. 校验通过，则不需要修改 
  7. 不通过，则向服务器请求

  强缓存的特点是不发送请求，直接使用本地缓存，通过设置Cache-Control来设置
  max-age, no-cache 本地不缓存， no-store 服务器不缓存

  协商缓存：发送请求验证缓存是否过期，通过校验Last-Modified 或者Etag

## 工程化

  ### 请解释前端工程化中的 Tree Shaking 原理。​
    
  Tree Shaking 的原理 依赖ES Module静态结构，在编译阶段分析导出和导入的关系，通过AST遍历识别未被引用的export，打包时，移除未被使用的代码；


  ### 什么是浏览器的ES Module

  ES Module是浏览器原生的模块化标准，通过import/export语法实现代码的结构化组织，解决了传统脚本标签的全局污染和依赖管理问题

  ### Webpack 中loader 和 Plugin的区别
  
  1. 核心职责不同
    Loader 负责将非js模块内容转换成js模块
    Plugin 负责扩展Webpack功能，干预整个打包流程
  2. 作用范围不同
    Loader 作用于单个模块，仅处理被匹配的文件类型
    Plugin 作用于整个构建流程，可全局干预打包流程
  3. 设计思想不同
    Loader 遵循“单一职责原则”，每个 Loader 专注于转换一种类型的文件
    Plugin 遵循“扩展原则”，通过钩子机制与 Webpack 内部流程集成，实现灵活的功能扩展

### Webpack的hash值有几种

  1. 若需要全局版本标识（如小型项目），使用 hash。
  2. 若多入口应用需要按 chunk 缓存，使用 chunkhash。
  3. 若静态资源（CSS、图片）需要独立缓存，使用 contenthash。

### 如何优化发布打包时长

### Vite 为什么本地启动比Webpack 快？

vite 本地启动快的核心是​​“按需加载”+“预构建缓存”+“ESM 原生支持”​​的三重优化：
  1. ​​按需加载​​：开发阶段不打包整个项目，浏览器按需请求 ESM 模块，减少初始计算量。
​  2. ​预构建缓存​​：通过 esbuild预转换依赖为 ESM 并缓存，避免重复处理。
  ​3. ​轻量架构​​：开发服务器仅处理必要的文件监听和 HMR，无复杂打包逻辑。

## TS

### void/never 的区别

- void：函数无返回值（如 function log(): void { console.log() }）。
- never：表示“永远不会返回”（如抛出错误的函数 function error(): never { throw new Error() }，或无限循环）。


### interface与type的区别

- 接口支持声明合并（同名接口自动合并），类型别名不支持。
- 接口更适合定义对象形状（可被类 implements），类型别名支持更复杂的类型操作（如联合、元组）。

### 为什么需要泛型

避免类型丢失。例如无泛型的 function identity(arg: any): any会丢失返回值类型信息（调用时无法确定具体类型），而泛型 identity<T>能保留类型（const num = identity(123)推断 num为 number）

```ts
function identity<T>(arg: T): T {
  return arg;
}
const str: string = identity('hello'); // 正确，类型保留为 string
```

### 什么是泛型约束

限制泛型类型​​：使用 extends关键字约束泛型必须满足某些条件（如 T extends number要求 T是 number或其子类型）。

```ts
function getLength<T extends { length: number }>(obj: T): number {
  return obj.length;
}
getLength('abc'); // 3（字符串有 length 属性）
getLength([1, 2]); // 2（数组有 length 属性）
```

### 解释条件类型的语法 T extends U ? X : Y，并举例说明其用途

如果T 能够赋值给U, 则类型为X, 否则就为Y

### ​​实现 Exclude<T, U>​​（排除 T中可赋值给 U的类型）

```ts
type MyExclude<T, U> = T extends U ? never: T
type Result = MyExclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'
```

### 如何用条件类型判断一个类型是否是数组？（如 T extends any[] ? true : false）

```ts
type IsArray<T> = T extends (infer U)[] ? true: false
```

### 什么是映射类型？如何用映射类型将对象的所有属性变为可选或只读？（如 Partial<T>、Readonly<T>）

​​映射类型​​：遍历原类型的属性，生成新类型（语法 [P in keyof T]: ...）。

```ts
type Partial<T> = {
  [K in keyof T]?: T[K]
}

type Readonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

### 实现一个工具类型 CamelToKebabCase<T>，将对象属性名的驼峰命名转为短横线命名（如 { fooBar: 1 }→ { 'foo-bar': 1 }）。

```ts
type CamelToKebabCase<S extends string> = S extends `${infer A}${infer B}`
  ? A extends Capitalize<A>
  ? `${Lowercase<A>}-${CamelToKebabCase<B>}`
  : `${A}-${CamelToKebabCase<B>}`
  : S

```

### infer关键字的作用是什么？如何在条件类型中使用 infer？

infer的作用​​：在条件类型中推断子类型（类似“类型变量”），常用于提取复杂类型的部分信息。

### 用 infer实现 ReturnType<T>工具类型（获取函数类型的返回值类型）。

```ts
type ReturnType<T extends (...args: any[]) => any> = T extends (...args:any[]) => infer R?R: never

```

### 如何为第三方库（如 lodash）添加类型声明？.d.ts文件的作用是什么？

第三方库类型声明​​：通过 .d.ts文件使用 declare module声明模块类型。例如为 lodash.debounce添加类型：

```ts
declare module 'lodash.debounce' {
  function debounce<T extends (...args: any[]) => any>(func: T, wait: number): T;
  export default debounce;
}

```

### Vue 3 中 defineComponent如何增强 TS 类型推导？举例说明。

​​defineComponent的类型增强​​：通过泛型推断 props、emits等类型

### tsconfig.json中 strict模式的含义是什么？开启后会影响哪些检查项？

strict模式​​：开启所有严格检查（包括 noImplicitAny、strictNullChecks等），显著提高类型安全性。

### noImplicitAny和 strictNullChecks的作用是什么？为什么推荐开启？

noImplicitAny与 strictNullChecks​​：
- noImplicitAny：禁止隐式 any类型（如未声明类型的变量），避免类型丢失。
- strictNullChecks：启用严格的 null/undefined检查（默认 null/undefined可赋值给任意类型，开启后需显式处理）。推荐开启以减少运行时错误。

### 如何优化 TS 编译速度？

​​优化编译速度​​：
- 启用 incremental: true（增量编译，缓存中间结果）。
- 使用 exclude排除 node_modules等无关目录。
- 大型项目使用 project references拆分多个子项目。

### 为什么避免滥用 any？如何逐步迁移项目中的 any类型？

避免滥用 any​​：any会绕过类型检查，导致运行时错误。迁移方法：逐步替换 any为具体类型，使用 unknown替代并添加类型守卫。


### 实现一个类型工具 PickByType<T, U>，从类型 T中筛选出属性值为 U类型的属性。示例：PickByType<{ name: string; age: number }, string>应返回 { name: string }。

```ts
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U? P: never]: T[P]
}
```

### 用泛型和类型约束实现一个 DeepReadonly<T>类型，将对象的所有嵌套属性变为只读。示例：DeepReadonly<{ a: { b: number } }>应返回 { readonly a: { readonly b: number } }。

```ts
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]>: T[P]
}

```

### 修复以下代码的类型错误：

```ts
function getValue(obj: { a?: number; b: string }): string | number {
  return obj.a || obj.b; // 报错：number | string 无法赋值给具体类型？
}
```

## 场景题

### 单点登录
  1. 定义：单点登录（Single Sign-On，SSO）​​ 是一种身份认证技术，允许用户通过​​一次登录操作​​访问多个关联的应用系统或服务，无需为每个系统重复输入账号和密码。
  2. 具体实现：
   ![单点登录](./截屏2025-08-06%2023.13.04.png)


## 编码

  ### 最长递增子序列
  ### 滑动窗口
  ### 防抖
  ### 节流
  ### Promise.all
  ### 实现一个函数 deepEqual深度比较两个对象是否相等
  ### 实现-个函数 deepClone 深拷贝
  ### DFS 实现 dom节点的查找
  ### 多维数组扁平化实现​
  ```js
  function flat(arr, n) {
    if (n === 0) return arr
    const len = arr.length
    const res = []
    for (let i = 0; i < len; i++) {
      if(Array.isArray(arr[i])){
        res.push(...flat(arr[i], n-1))
      } else {
        res.push(arr[i])
      }
    }
    return res
  }
  ```